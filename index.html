<html><head>
	<meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <nav id="navbar">
		<header>Regex Documentation</header>
		<ul>
			<li><a class="nav-link" href="#Introduction">Введение</a></li>
			<li>
				<a class="nav-link" href="#test">test()</a>
			</li>
			<li>
				<a class="nav-link" href="#match">match()</a>
			</li>
			<li>
				<a class="nav-link" href="#replace">replace()</a>
			</li>
			<li>
				<a class="nav-link" href="#example">Примеры</a>
			</li>
			
		</ul>
	</nav>
    <main id="main-doc">
		<section class="main-section" id="Introduction">
			<header>Введение.</header>
			<article>
				<p>
					Регулярные выражения, часто сокращаемые до «regex» или «regexp», представляют собой шаблоны, которые помогают программистам сопоставлять, искать и заменять текст. Регулярные выражения очень эффективны, но их трудно читать, поскольку они используют специальные символы для создания более сложных и гибких соответствий.
					
				</p>
			</article>
		</section>
		<section class="main-section" id="test">
			<header>Использование метода <i>test()</i>.</header>
			<article>
				<p>
					Если вы хотите найти слово <b>the</b> в строке The <b><i>dog chased the cat</i></b>, вы можете использовать следующее регулярное выражение: <code>/the/</code>. Обратите внимание, что в регулярном выражении не требуются кавычки.
				</p>
				<p>
					В JavaScript есть несколько способов использования регулярных выражений. Один из способов проверить регулярное выражение — использовать <b>.test()</b> метод. Метод <b>.test()</b> принимает регулярное выражение, применяет его к строке (которая помещается в круглые скобки) и возвращает <b>true</b> или <b>false</b>, если ваш шаблон что-то находит или нет:
				</p>
				<code>
					// Метод <b>test</b> здесь возвращает <b>true</b>.
					let testStr = "freeCodeCamp";
					let testRegex = /Code/;
					testRegex.test(testStr);
				</code>
				<p>Регулярное выражение /Сode/ не будет соответствовать code или CODE
				</article>
				<span class="sub"><h3>Искать несколько шаблонов, используя ИЛИ: |</h3></span>
				<p>Этот оператор сопоставляет шаблоны либо до, либо после него. Например, если вы хотите сопоставить строки yesили no, вам нужно регулярное выражение /yes|no/</p>
				<p>Мождо добавить больше шаблонов с большим количеством OR операторов, разделяющих их, например: <code><b>/yes|no|maybe/</b>
					let petString = "James has a pet cat.";
					let petRegex = /dog|cat|bird|fish/;
				let result = petRegex.test(petString);</code>.</p>
				
				<span class="sub"><h3>Флаг <span class="flag">i</span></h3></span>
				<p>Регистр (или иногда регистр букв) — это разница между прописными и строчными буквами. Примеры прописных букв: A, B, и C.
				Примерами нижнего регистра являются a, b и c.</p>
				<p>Можно сопоставить оба случая, используя так называемый флаг. Есть и другие флаги, но здесь вы сосредоточитесь на флаге, который игнорирует регистр — флаг <b>i</b>.Пример использования этого флага: <code> /ignorecase/i</code>. Это регулярное выражение может соответствовать строкам <b> ignorecase, igNoreCaseи IgnoreCase</b>.
					<code>let myString = "freeCodeCamp";
						let fccRegex = /freeCodeCamp/i;
						let result = fccRegex.test(myString);
					</code>
				</p>
				<p style="margin-left:40%; font-size:20px;">Подстановочный знак <span style="margin-left:10px;font-size:5em;">.</span></p>
				<p>Подстановочный знак . будет соответствовать любому одному символу. Подстановочный знак также называется <mark>dot</mark> и <mark>period</mark>. Вы можете использовать подстановочный знак так же, как и любой другой символ в регулярном выражении. Например, если вы хотите сопоставить <i>hug, huh, hutи hum</i>, можно использовать регулярное выражение  <mark><b>/hu./</b></mark>  для сопоставления всех четырех слов:
					<code>
						let humStr = "I'll hum a song";
						let hugStr = "Bear hug";
						let huRegex = /hu./;
						huRegex.test(humStr);
					huRegex.test(hugStr);</code>
				</p>
				
				<span class="sub"><h3>Cпецификатор количества.</h3></span>
				<p>Чтобы сопоставить определенный диапазон символов можно использовать <mark><b>спецификатор количества</b></mark>.
					<p>Спецификаторы количества используются с фигурными скобками ( <b>{</b> и <b>}</b> ). Вы ставите между фигурными скобками две цифры - для нижнего и верхнего диапазона искомых значений.Сколько раз значенте(или буква) встречаются в данном слове.</p>
					<code>let A4 = "aaaah";
						let A2 = "aah";
						let multipleA = /a{3,5}h/;
						multipleA.test(A4);
						multipleA.test(A2);
					// Первый test вызов вернется true т.к. ,буква "a" встречается от 3-х раз в слове, а второй вернется false.</code>
					<span class="sub"><h3>Cпецификатор количества без верхнего предела.</h3></span>
					<code>let A4 = "haaaah";
						let A2 = "haah";
						let A100 = "h" + "a".repeat(100) + "h";
						let multipleA = /ha{3,}h/;
						multipleA.test(A4);
						multipleA.test(A2);
						multipleA.test(A100);
						
					// По порядку три test вызова вернут true, false и true.</code>
					<span class="sub"><h3>Cпецификатор точного количества совпадений.</h3></span>
					<p>Чтобы сопоставить слово <b>hah</b> с буквой <a>a</b>именно 3 раза, регулярное выражение будет <mark><b>/ha{3}h/</b></mark>.
						<code>let A4 = "haaaah";
							let A3 = "haaah";
							let A100 = "h" + "a".repeat(100) + "h";
							let multipleHA = /ha{3}h/;
							multipleHA.test(A4);
							multipleHA.test(A3);
							multipleHA.test(A100);
							
							// По порядку три test вызова вернут false, true и false.
						</code>
						<span class="sub"><h3>Проверить все или ничего.</h3></span>
						<p>Можно указать возможное существование элемента с помощью знака вопроса, <mark><b>( ? )</b></mark>. Это проверяет наличие нуля или одного из предыдущих элементов. Можно думать об этом символе как о том, что предыдущий элемент является необязательным.</p>
						<p>Например, в американском и британском английском есть небольшие различия, и вы можете использовать вопросительный знак, чтобы соответствовать обоим вариантам написания.</p>
						<code>let american = "color";
							let british = "colour";
							let rainbowRegex= /colou?r/;
							rainbowRegex.test(american);
							rainbowRegex.test(british);
						Оба варианта использования метода test вернут true.</code>
						<span class="sub"><h3>Проверка группы символов.</h3></span>
						<p>Для проверки групп используются круглые скобки <mark><b>()</b></mark>
							<code>let testStr = "Pumpkin";
								let testRegex = /P(engu|umpk)in/;
								testRegex.test(testStr);
								
								// Метод test здесь вернет true.
							</code>
							<p>Повторное использование шаблонов с помощью групп захвата.<mark><b>()</b></mark>
								<p>Допустим, нужно сопоставить слово, которое встречается несколько раз, как показано ниже.</p>
								<code>let repeatStr = "row row row your boat";</code>
								<p>Можно использовать <b>/row row row/</b>, но что, если вы не знаете повторяющееся конкретное слово? Группы захвата можно использовать для поиска повторяющихся подстрок.
									<p>Группы захвата создаются путем заключения шаблона регулярного выражения в круглые скобки. В этом случае цель состоит в том, чтобы захватить слово, состоящее из буквенно-цифровых символов, поэтому группа захвата будет <mark><b>\w+</b></mark> заключена в круглые скобки: <mark><b>/(\w+)/</b></mark>.
										<p>Подстрока, соответствующая группе, сохраняется во временной «переменной», к которой можно получить доступ в том же регулярном выражении, используя обратную косую черту и номер группы захвата (например, \1). Группы захвата автоматически нумеруются по положению открывающих скобок (слева направо), начиная с 1.
											
										Пример ниже соответствует слову, которое встречается трижды через пробел:</p>
										<code>let repeatRegex = /(\w+) \1 \1/;
											repeatRegex.test(repeatStr); // Returns true
											repeatStr.match(repeatRegex); // Returns ["row row row", "row"]
											
										// Использование <b>.match()</b> метода для строки вернет массив с совпадающей подстрокой вместе с ее захваченными группами.</code>
									</section>
									<!-- +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++match()+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
									<section class="main-section" id="match">
										<header>Использование метода <i>match()</i>.</header>
										<article>
											<p>Чтобы использовать .match() метод, примените метод к строке и передайте регулярное выражение в круглых скобках:</p>
											<code>
												"Hello, World!".match(/Hello/);
												let ourStr = "Regular expressions";
												let ourRegex = /expressions/;
												ourStr.match(ourRegex);
											</code>
											<p>.match синтаксис является «противоположным» методу, .test:
												<code>
													'string'.match(/regex/);
													/regex/.test('string');
												</code>
											</p>
											<span class="sub"><h3>Флаг <span class="flag">g</span></h3></span>
											<p>Чтобы искать или извлекать шаблон более одного раза, можно использовать флаг глобального поиска: g</p>
											<code>
												let testStr = "Repeat, Repeat, Repeat";
												let repeatRegex = /Repeat/g;
												testStr.match(repeatRegex);
											</code>
											<p>И здесь match возвращает значение ["Repeat", "Repeat", "Repeat"]</p>
											<p>В регулярном выражении может быть несколько флагов, например <b> /search/gi </b></p>
											<span class="sub"><h3>Классы символов.</h3></span>
											<p>Классы символов позволяют определить группу символов, которые нужно сопоставить, поместив их в квадратные ( <mark>[</mark>  и  <mark>]</mark> ) скобки.</p>
											<p>Этот <mark>[aiu]</mark> класс символов, который будет соответствовать только символам <mark>a</mark>, <mark>i</mark> или <mark>u</mark>:</p>
											<code>let bigStr = "big";
												let bagStr = "bag";
												let bugStr = "bug";
												let bogStr = "bog";
												let bgRegex = /b[aiu]g/;
												bigStr.match(bgRegex);
												bagStr.match(bgRegex);
												bugStr.match(bgRegex);
											bogStr.match(bgRegex);</code>
											<span class="sub"><h3>Совпадение букв алфавита.</h3></span>
											<p>Внутри набора символов можно определить диапазон символов для соответствия с помощью символа дефиса: <mark><b>-</b></mark>:</p>
											<code>let catStr = "cat";
												let batStr = "bat";
												let matStr = "mat";
												let bgRegex = /[a-e]at/;
												catStr.match(bgRegex);
												batStr.match(bgRegex);
												matStr.match(bgRegex);
											</code>
											<p>По порядку три match вызова вернут значения <mark>["cat"]</mark>, <mark>["bat"]</mark> и <mark>null</mark>.</p>
											<span class="sub"><h3>Совпадение чисел и букв алфавита.</h3></span>
											<p>Использование дефиса ( - ) для соответствия диапазону символов не ограничивается буквами. Он также работает, чтобы соответствовать диапазону чисел.
												Например, /[0-5]/ соответствует любому числу между 0 и 5, включая 0 и 5.
											Кроме того, можно комбинировать диапазон букв и цифр в одном наборе символов.</p>
											<code>let jennyStr = "Jenny8675309";
												let myRegex = /[a-z0-9]/ig;
											jennyStr.match(myRegex);</code>
											<span class="sub"><h3>Наборы символов с отрицанием.</h3></span>
											<p>Можно создать набор символов, которые вы не нужно сопоставлять. Эти типы наборов символов называются наборами символов с отрицанием</p>
											<p>Чтобы создать набор символов с отрицанием, помещается символ вставки ( ^ ) после открывающей скобки и перед символами, которые не должны совпадать.</p>
											<p>Например, <mark>/[^aeiou]/gi</mark> соответствует всем символам, <b>не</b> являющимся гласными. Такие символы, как <mark>., !, [, @, /</mark> и <mark>пробел</mark> совпадают — набор символов с отрицанием гласных исключает только символы гласных.</p>
											<span class="sub"><h3>Сопоставьтеавление символов, которые встречаются один или несколько раз.</h3></span>
											<p>Можно использовать + символ, чтобы проверить, так ли это. Помни, что символ или шаблон должны присутствовать последовательно. То есть персонаж должен повторяться один за другим.</p>
											Например, <b>/a+/g</b> найдет одно совпадение <mark>abc</mark> и вернет <b>["a"]</b>. Из-за <b>+</b>, он также найдет одно совпадение <b>aabc</b> и вернет <b>["aa"]</b>.
											<p>Если бы он вместо этого проверял строку <b>abab</b>, он нашел бы два совпадения и вернул бы результат <b>["a", "a"]</b>, потому что aсимволы не стоят в строке —  между ними есть знак <b>b</b>. Наконец, поскольку в строке нет <b>bcd</b>, совпадение не будет найдено.</p>
											<span class="sub"><h3>Соответствие символам, которые встречаются ноль или более раз.</h3></span>
											<p>Существует также параметр, который соответствует символам, встречающимся ноль или более раз.
												
											Символ для этого — звездочка или звездочка: <b>*</b>.</p>
											<code>let soccerWord = "gooooooooal!";
												let gPhrase = "gut feeling";
												let oPhrase = "over the moon";
												let goRegex = /go*/;
												soccerWord.match(goRegex);
												gPhrase.match(goRegex);
											oPhrase.match(goRegex);</code>
											<p>По порядку три matchвызова вернут значения <b>["goooooooo"], ["g"], null</b>.</p>
											<span class="sub"><h3>Поиск символов с ленивым сопоставлением.</h3></span>
											<p>В регулярных выражениях жадное совпадение находит максимально длинную часть строки, которая соответствует шаблону регулярного выражения, и возвращает ее как совпадение. Альтернатива называется ленивым сопоставлением, которое находит наименьшую возможную часть строки, удовлетворяющую шаблону регулярного выражения.</p>
											<p>Выражение <mark><b>/t[a-z]*i/</b></mark> к строке <i>"titanic"</i>. Это регулярное выражение в основном представляет собой шаблон, который начинается с <b>t</b>, заканчивается на <b>i</b> и имеет несколько букв между ними.
												<p>Регулярные выражения по умолчанию являются жадными, поэтому совпадение возвращает <mark>["titani"]</mark>. Он находит самую большую подстроку, соответствующую шаблону.</p>
												<p>Однако можно использовать <b>?</b> символ, чтобы изменить его на ленивое сопоставление. <b>"titanic"</b> сопоставляется с скорректированным регулярным выражением <mark><b>/t[a-z]*?i/</b></mark> вернет <mark><b>["ti"]</b></mark>.</p>
												<span class="sub"><h3>Совпадение с шаблонами начальных строк.</h3></span>
												<p>Вне набора символов знак вставки используется для поиска шаблонов в начале строк.</p>
												<code>
													let firstString = "Ricky is first and can be found.";
													let firstRegex = /^Ricky/;
													firstRegex.test(firstString);
													let notFirst = "You can't find Ricky now.";
												firstRegex.test(notFirst);</code>
												<p>Первый <b>test</b> вызов вернется <b>true</b>, а второй вернется <b>false</b>.</p>
												<span class="sub"><h3>Совпадение с шаблонами конечных строк.</h3></span>
												<p>Можно искать конец строки, используя символ доллара <mark><b>$</b></mark> в конце регулярного выражения: </p>
												<code>let theEnding = "This is a never ending story";
													let storyRegex = /story$/;
													storyRegex.test(theEnding);
													let noEnding = "Sometimes a story will have to end";
												storyRegex.test(noEnding);</code>
												<p>Первый <b>test</b> вызов вернется <b>true</b>, а второй вернется <b>false</b>.</p>
												<span class="sub"><h3>Сопоставьте все буквы и цифры.</h3></span>
												<p>Используя классы символов, вы могли искать все буквы алфавита с помощью <b>[a-z]</b>. Этот тип класса символов достаточно распространен, поэтому для него есть ярлык, хотя он также включает в себя несколько дополнительных символов.
													
												Ближайший класс символов в JavaScript, соответствующий алфавиту, — это <mark><b>\w</b></mark>. Этот ярлык равен <mark><b>[A-Za-z0-9_]</b></mark>. Этот класс символов соответствует прописным и строчным буквам, а также цифрам. Обратите внимание, что этот класс символов также включает символ подчеркивания <b><mark>( _ )</mark></b>.</p>
												<code>
													let longHand = /[A-Za-z0-9_]+/;
													let shortHand = /\w+/;
													let numbers = "42";
													let varNames = "important_var";
													longHand.test(numbers);
													shortHand.test(numbers);
													longHand.test(varNames);
													shortHand.test(varNames);
													
													// Все четыре из этих test вызовов вернутся true.
												</code>
												<p>Эти классы сокращенных символов также известны как <b>классы сокращенных символов</b></p>
												<span class="sub"><h3>Сопоставьте все, кроме букв и цифр.</h3></span>
												<p>Противоположный ярлык <mark>\w</mark> - это  <b><mark>\W</mark></b>. Обратите внимание, что в противоположном шаблоне используется заглавная буква. Этот ярлык такой же, как <b>[^A-Za-z0-9_]</b>.</p>
												<code>let shortHand = /\W/;
													let numbers = "42%";
													let sentence = "Coding!";
													numbers.match(shortHand);
													sentence.match(shortHand);
													
													// Первый match вызов вернет значение ["%"], а второй вернет ["!"].
												</code>
												<span class="sub"><h3>Совпадение со всеми числами.</h3></span>
												<p>Ярлык для поиска цифровых символов — <mark><b>\d</b></mark> строчные буквы <b>d</b>. Это равно классу символов <b>[0-9]</b>, который ищет один символ любого числа от нуля до девяти.</p>
												<span class="sub"><h3>Совпадение со всеми нечисловыми значениями.</h3></span>
												<p>Ярлык для поиска нецифровых символов — <mark><b>\D</b></mark>. Это равно классу символов <b>[^0-9]</b>, который ищет единственный символ, который не является числом от нуля до девяти.<p>
													<span class="sub"><h3>Совпадение с пробелами.</h3></span>
													<p>Искать пробелы <mark><b>\s</b></mark>, используя строчные буквы <mark><b>s</b>
													</mark>. Этот шаблон соответствует не только пробелам, но и символам возврата каретки, табуляции, перевода страницы и новой строки. Можно думать об этом как о классе символов <mark>[ \r\t\f\n\v ]</mark>.
													<code>
														let whiteSpace = "Whitespace. Whitespace everywhere!"
														let spaceRegex = /\s/g;
														whiteSpace.match(spaceRegex);
														
														// Этот match вызов вернет [" ", " "].
													</code>
													<span class="sub"><h3>Совпадение с непробельными символами.</h3></span>
													<p> Можно также искать все кроме пробелов используя <mark><b>\S</b></mark> шаблон.
														Это аналог <mark>[^\r\t\f\n\v]</mark>
														<code>
															let whiteSpace = "Whitespace. Whitespace everywhere!"
															let nonSpaceRegex = /\S/g;
															whiteSpace.match(nonSpaceRegex).length;
															
															// Значение, возвращаемое методом, .length будет 32.
														</code>
														<span class="sub"><h3>Lookaheads.</h3></span>
														<p>Lookaheads — это шаблоны, которые сообщают JavaScript о том, что нужно смотреть вперед в вашей строке, чтобы проверить наличие шаблонов дальше. Это может быть полезно, когда вы хотите найти несколько шаблонов в одной и той же строке.
															
															Существует два вида просмотра вперед: <b>положительный просмотр вперед</b> и <b>отрицательный просмотр вперед</b> .
															
															Положительный просмотр вперед проверяет наличие элемента в шаблоне поиска, но на самом деле не соответствует ему. Положительный просмотр вперед используется, <mark><b>(?=...)</b></mark> когда <mark><b>...</b></mark> является требуемой частью, которая не соответствует.
															
														С другой стороны, отрицательный просмотр вперед будет проверять, что элемента в шаблоне поиска нет. Отрицательный просмотр вперед используется как <mark><b>(?!=...)</b></mark>) шаблон <mark><b>...</b></mark>, который вам не нужен. Остальная часть шаблона возвращается, если отрицательная часть просмотра вперед отсутствует.</p>
														<code>let quit = "qu";
															let noquit = "qt";
															let quRegex= /q(?=u)/;
															let qRegex = /q(?!u)/;
															quit.match(quRegex);
															noquit.match(qRegex);
															
														// Оба этих match вызова вернутся ["q"].</code>
														<p>Более практичное использование просмотра вперед — это проверка двух или более шаблонов в одной строке. Вот (наивно) простая проверка пароля, которая ищет от 3 до 6 символов и по крайней мере одну цифру:</p>
														<code>let password = "abc123";
															let checkPass = /(?=\w{3,6})(?=\D*\d)/;
															checkPass.test(password);
															let password = "abc123";
															let checkPass = /(?=\w{3,6})(?=\D*\d)/;
														checkPass.test(password);</code>
													</article>
													
													<!--********************************************************************replace()*************************************************************-->
													
													<section class="main-section" id="replace">
														<header>Использование метода <i>replace()</i>.</header>
														<article>
															<span class="sub"><h3>Группы захвата для поиска и замены.</h3></span>
															<p>Можно искать и заменять текст в строке, используя <mark>.replace()</mark> метод. Входные данные для .replace()- это сначала шаблон регулярного выражения, который вы хотите найти. Второй параметр — это строка для замены совпадения или функция, которая что-то делает.</p>
															<code>let wrongText = "The sky is silver.";
																let silverRegex = /silver/;
																wrongText.replace(silverRegex, "blue");
																
															// Вызов replace eвернет строку "The sky is blue".</code>
															<p>Также можно получить доступ к группам захвата в строке замены с помощью знаков доллара <b>( $ )</b>.</p>
															<code>"Code Camp".replace(/(\w+)\s(\w+)/, '$2 $1');
																
															// Вызов replaceвернет строку Camp Code.</code>
														</article>
													</section>
													<!--++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++examples++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
													
													<section class="main-section" id="example">
														<header> Примеры </header>
														<article>
															<span class="sub"><h3>Ограничить возможные имена пользователей.</h3></span>
															<ol>
																<li>Имена пользователей могут использовать только буквенно-цифровые символы.</li>
																<li>Единственные цифры в имени пользователя должны быть в конце. В конце их может быть ноль или больше. Имя пользователя не может начинаться с цифры.</li>
																<li>Буквы имени пользователя могут быть строчными и прописными.</li>
																<li>Имя пользователя должно быть не менее двух символов. Двухсимвольное имя пользователя может использовать только буквы алфавита в качестве символов.</li>
															</ol>
															<code>
																let username = "JackOfAllTrades";
																let userCheck = /^[a-z][a-z]+\d*$|^[a-z]\d\d+$/i;
																let result = userCheck.test(username);
																console.log(result)
															</code>
															<span class="sub"><h3>Использование Lookaheads для сопоставления паролей, длина которых превышает 5 символов и состоит из двух последовательных цифр.</h3></span>
															<code>let sampleWord = "astronaut";
																let pwRegex =  /(?=\w{6,})(?=\w*\d{2})/;
															let result = pwRegex.test(sampleWord);</code>
															<span class="sub"><h3>Удалить пробелы в начале и конце.</h3></span>
															<code>let hello = "   Hello, World!  ";
																let wsRegex = /^\s+|\s+$/g;
															    let result = hello.replace(wsRegex,"");
															</code>
														</article>
													</section>
													
													</main>
													
													
												</body></html>												